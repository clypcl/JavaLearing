面试问题
一.面向对象的4大特性
1.抽象------ 抽象，就是将一类对象的共同特征总结归纳出来构造类的过程。包括数据抽象 和 行为抽象。抽象只关注对象的属性和行为，对行为的具体细节并不关注。

2.继承------ 继承，就是从已有类得到继承信息创建新的类的过程。继承让变化的软件系统有了一定的延续性，同时也是封装过程中可变因素的重要手段。

3.封装------ 通常认为是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口，面向对象的本质就是将现实世界描绘成一组完全自治，封闭的对象。
            在类中编写的方法其实是对实现细节的封装，编写的类其实是对数据和数据操作的封装。封装隐藏所有可以隐藏的，只向外接提供简单的编程接口
            
4.多态------ 多态是指 允许不同子类型的对象对同一消息做出不同的响应。就是用同样的对象引用  调用同样的方法但是做了不同的事情。多态包括编译时的多态和运
            行时的多态。如果将对象的方法视为对象向外界提供的服务，那么运行时多态可以理解为：A系统访问B系统的服务是,B系统有多种提供服务的方式，但对A
            来说是透明的。方法重载（overload）实现的是编译时的多态性，方法重写（override）实现的是运行时的多态性；运行时多态是面向对象的精髓，要实
            现多态：1.）方法重写--子类继承父类并重写父类中已有的或抽象的方法。 2.）对象造型--父类引用 引用子类对象，这样同样的引用调用同样的方法会根
            据 子类的不同表现出不同的行为。
            
二.&和&&的区别 
   &有两种用法，1.）按位与 2.）逻辑与 ，&&运算符是短路与。两者都要求运算符两边的布尔值都为true的时候整个表达式的值才返回true。&&称为短路与，是因为
运算符左边表达式的值如果为false，右边的表达式会直接短路掉，不会进行运算。

三.内存中的栈（stack）、堆（heap）和静态区（static area）的用法
1.栈---通常定义的基本数据类型的变量，一个对象的引用，函数调用的现场保存 都是使用的栈空间
2.堆---通过new关键字和构造器创建的对象 存放在 堆空间
3.静态区---程序中的字变量和常量存放在静态区
栈空间操作很快但是栈很小，通常大量的对象都放在堆内存上。理论上整个内存没有被其他进程使用的空间都可以看成是堆内存
          String str = new String("hello");
str存放在栈中，new出来的字符串对象放在堆中，hello放在静态区

四.两个对象的值满足x.equals(y)==true，那么他们的哈希码应该相同。java中对于equals方法和hashCode方法是这样规定的：
1.如果两个对象相同，那么hashCode一定要相同。
2.如果两个对象的hashcode相同，他们并不一定相同。
equals方法必须满足的条件：1.）自反性（x.equals(x)必须返回true）        2.）对称性(x.equals(y)返回true时，y.equals(x)也必须返回true)
                        3.）传递性（x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)也必须返回true）
                        4.）统一性（当x和y的引用信息没有被修改时，多次访问x.equals(y)得到的返回值必须相同），对于任何非null的引用x，
                           x.equals(null)返回的值必须是false。
高质量equals方法的诀窍：  1.）使用==操作符检查"参数是否为这个对象的引用"
                        2.）使用instanceof检查"参数的类型是否正确" 
                        3.）对于类中的关键属性，检查参数传入对象的属性是否与之匹配
                        4.）写完equals方法后，检查是否满足以上条件
                        5.）重写equals方法时都要重写hashcode 方法
                        6.）不要将equals方法中的参数Object对象替换成其他类型的参数，重写是要用@Override注解
   
五.String 和 StringBuild、StringBuffer的区别
   都可以存储和操作字符串。String是只读字符串，引用的字符串内容不能被修改。StringBuild和StringBuffer类表示的字符串对象可以直接进行修改。
StringBuild 与 StringBuffer方法完全相同，StringBuild是单线程环境下使用的，所有方法没有被synchronized修饰，所以效率较高

六.重载和重写的区别。重载的方法能否根据返回类型 来区分？
   方法的重载和重写都是实现多态的方式。区别是前者是编译时的多态，后者是运行时的多态。重载发生在一个类里，同名的方法如果有不同的参数列表，视为
重载。重写发生在子类与父类之间，重写要求子类的被重写方法与父类的被重写方法有相同的返回类型，比父类被重写方法更好访问，不能抛出比父类被重写方法
更多的异常。重载对返回类型没有特殊要求

七.JVM加载class文件的原理机制
    JVM中类的加载是由类加载器（ClassLoader）和他的子类来实现的。java中的类加载器是一个重要的运行时系统组件，负责运行时查找和装入类文件中的类。
当java程序需要某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指将类的.class文件中的数据读入到内存中，通常
是创建一个字节数组读入.class文件，然后产生于所加载类相对应的Class对象。当类被加载后就进入连接阶段，一般包括验证、准备（为静态变量分配内存并设置
默认的初始值）和解析（将符号引用替换成直接引用）三个阶段。最后JVM对类进行初始化，包括：1.）如果类存在直接的父类并且该类没有被初始化，那么就先初
始化父类  2.）如果类中存在初始化语句，那么依次执行这些初始化语句。
    类的加载是由类加载器完成的，类加载器包括：根加载器（Bootstrap）、拓展加载器（Extension）、系统加载器（System）和用户自定义类加载
器（java.lang.ClassLoader的子类）。类加载过程中采用了父类委托机制（PDM），更好的保证了java平台的安全性，在该机制中，Bootstrap是根加载器，其
他的类加载器有且只有一个父类加载器，类的加载首先请求父类加载器加载，父类无法完成时才由其子加载器自行加载。
1.Bootstrap：一般由本地代码实现，主要负责加载JVM基础核心类库（rt.jar）
2.Extension：从java.ext.dirs系统属性中指定的目录中加载类库，它的父加载器是Bootstrap
3.System：又叫应用类加载器，其父类是Extension。他从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，是用户自定义类加载器的默
认父加载器

八.抽象类与接口的区别
    抽象类和接口都不能被实例化，但可以定义抽象类和接口的引用。一个类如果继承了某个抽象类或者实现了某个接口，都需要对其中的抽象方法全部进行实现， 
否则该类仍然需要被声明为抽象类。接口比抽象类 更加抽象，因为抽象类可以定义构造器，可以有抽象方法和具体方法 ，接口不能定义构造器，而且里面的方法全
都是抽象方法。抽象类中的成员可以是private、默认、protected、public，接口里面的成员全部都是public。抽象类中可以定义成员变量，接口定义的成员变量 
都是常量。有抽象方法的类必须被声明为抽象类，抽象类未必要有抽象方法。

九.静态嵌套类和内部类的区别
    静态嵌套类是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。内部类需要外部类实例化后才能实例化。java中的非静态内部类对象的
创建需要依赖外部类对象，静态方法中没有this，即没有外部类对象，因此无法创建内部类。

十.java中的内存泄漏问题
    理论上，java因为有垃圾回收机制（GC），不会存在内存泄漏问题。现实开发是，可能存在无用但可达的对象，这些对象无法被GC 回收，因此导致了内存泄漏 
的发生。在支持垃圾回收的语言中，内存泄漏其实是无意识的对象保存。如果一个对象被无意识的保存，垃圾回收不会处理这个对象，也不会处理该对象引用的其他
对象，这可能导致很多对象被排除在垃圾回收之外，对性能造成严重影响，甚至造成OutOfMemeryError
    

